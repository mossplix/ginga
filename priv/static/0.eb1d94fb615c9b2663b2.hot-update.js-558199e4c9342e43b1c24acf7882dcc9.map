{"version":3,"sources":["webpack:///./web/static/js/app/utils/text_formatting.jsx?37fc"],"names":[],"mappings":"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","file":"0.eb1d94fb615c9b2663b2.hot-update.js","sourcesContent":["// Copyright (c) 2015 Mattermost, Inc. All Rights Reserved.\n// See License.txt for license information.\n\nimport Autolinker from 'autolinker';\nimport Constants from '../constants/chat_constants';\nimport * as Emoticons from './emoticons';\nimport * as Markdown from './markdown';\nimport * as Utils from './general';\n\n\n// Performs formatting of user posts including highlighting mentions and search terms and converting urls, hashtags, and\n// @mentions to links by taking a user's message and returning a string of formatted html. Also takes a number of options\n// as part of the second parameter:\n// - searchTerm - If specified, this word is highlighted in the resulting html. Defaults to nothing.\n// - mentionHighlight - Specifies whether or not to highlight mentions of the current user. Defaults to true.\n// - singleline - Specifies whether or not to remove newlines. Defaults to false.\n// - emoticons - Enables emoticon parsing. Defaults to true.\n// - markdown - Enables markdown parsing. Defaults to true.\nexport function formatText(text, options = {}) {\n    let output;\n\n    if (!('markdown' in options) || options.markdown) {\n        // the markdown renderer will call doFormatText as necessary\n        output = Markdown.format(text, options);\n    } else {\n        output = sanitizeHtml(text);\n        output = doFormatText(output, options);\n    }\n\n    // replace newlines with spaces if necessary\n    if (options.singleline) {\n        output = replaceNewlines(output);\n    }\n\n    return output;\n}\n\n// Performs most of the actual formatting work for formatText. Not intended to be called normally.\nexport function doFormatText(text, options) {\n    let output = text;\n\n    const tokens = new Map();\n\n    // replace important words and phrases with tokens\n    output = autolinkAtMentions(output, tokens);\n    output = autolinkEmails(output, tokens);\n    output = autolinkHashtags(output, tokens);\n\n    if (!('emoticons' in options) || options.emoticon) {\n        output = Emoticons.handleEmoticons(output, tokens);\n    }\n\n    if (options.searchTerm) {\n        output = highlightSearchTerm(output, tokens, options.searchTerm);\n    }\n\n    if (!('mentionHighlight' in options) || options.mentionHighlight) {\n        output = highlightCurrentMentions(output, tokens);\n    }\n\n    // reinsert tokens with formatted versions of the important words and phrases\n    output = replaceTokens(output, tokens);\n\n    return output;\n}\n\nexport function sanitizeHtml(text) {\n    let output = text;\n\n    // normal string.replace only does a single occurrance so use a regex instead\n    output = output.replace(/&/g, '&amp;');\n    output = output.replace(/</g, '&lt;');\n    output = output.replace(/>/g, '&gt;');\n    output = output.replace(/'/g, '&apos;');\n    output = output.replace(/\"/g, '&quot;');\n\n    return output;\n}\n\n// Convert emails into tokens\nfunction autolinkEmails(text, tokens) {\n    function replaceEmailWithToken(autolinker, match) {\n        const linkText = match.getMatchedText();\n        let url = linkText;\n\n        if (match.getType() === 'email') {\n            url = `mailto:${url}`;\n        }\n\n        const index = tokens.size;\n        const alias = `MM_EMAIL${index}`;\n\n        tokens.set(alias, {\n            value: `<a class=\"theme\" href=\"${url}\">${linkText}</a>`,\n            originalText: linkText\n        });\n\n        return alias;\n    }\n\n    // we can't just use a static autolinker because we need to set replaceFn\n    const autolinker = new Autolinker({\n        urls: false,\n        email: true,\n        phone: false,\n        twitter: false,\n        hashtag: false,\n        replaceFn: replaceEmailWithToken\n    });\n\n    return autolinker.link(text);\n}\n\nfunction autolinkAtMentions(text, tokens) {\n    // Return true if provided character is punctuation\n    function isPunctuation(character) {\n        const re = /[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,\\-.\\/:;<=>?@\\[\\]^_`{|}~]/g;\n        return re.test(character);\n    }\n\n    // Test if provided text needs to be highlighted, special mention or current user\n    function mentionExists(u) {\n        return (Constants.SPECIAL_MENTIONS.indexOf(u) !== -1); //|| UserStore.getProfileByUsername(u));\n    }\n\n    function addToken(username, mention) {\n        const index = tokens.size;\n        const alias = `MM_ATMENTION${index}`;\n\n        tokens.set(alias, {\n            value: `<a class='mention-link' href='#' data-mention='${username}'>${mention}</a>`,\n            originalText: mention\n        });\n        return alias;\n    }\n\n    function replaceAtMentionWithToken(fullMatch, mention, username) {\n        let usernameLower = username.toLowerCase();\n\n        if (mentionExists(usernameLower)) {\n            // Exact match\n            const alias = addToken(usernameLower, mention, '');\n            return alias;\n        }\n\n        // Not an exact match, attempt to truncate any punctuation to see if we can find a user\n        const originalUsername = usernameLower;\n\n        for (let c = usernameLower.length; c > 0; c--) {\n            if (isPunctuation(usernameLower[c - 1])) {\n                usernameLower = usernameLower.substring(0, c - 1);\n\n                if (mentionExists(usernameLower)) {\n                    const suffix = originalUsername.substr(c - 1);\n                    const alias = addToken(usernameLower, '@' + usernameLower);\n                    return alias + suffix;\n                }\n            } else {\n                // If the last character is not punctuation, no point in going any further\n                break;\n            }\n        }\n\n        return fullMatch;\n    }\n\n    let output = text;\n    output = output.replace(/(@([a-z0-9.\\-_]*))/gi, replaceAtMentionWithToken);\n\n    return output;\n}\n\nfunction escapeRegex(text) {\n    return text.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\nfunction highlightCurrentMentions(text, tokens) {\n    let output = text;\n\n    const mentionKeys =[];// UserStore.getCurrentMentionKeys();\n\n    // look for any existing tokens which are self mentions and should be highlighted\n    var newTokens = new Map();\n    for (const [alias, token] of tokens) {\n        if (mentionKeys.indexOf(token.originalText) !== -1) {\n            const index = tokens.size + newTokens.size;\n            const newAlias = `MM_SELFMENTION${index}`;\n\n            newTokens.set(newAlias, {\n                value: `<span class='mention--highlight'>${alias}</span>`,\n                originalText: token.originalText\n            });\n            output = output.replace(alias, newAlias);\n        }\n    }\n\n    // the new tokens are stashed in a separate map since we can't add objects to a map during iteration\n    for (const newToken of newTokens) {\n        tokens.set(newToken[0], newToken[1]);\n    }\n\n    // look for self mentions in the text\n    function replaceCurrentMentionWithToken(fullMatch, prefix, mention) {\n        const index = tokens.size;\n        const alias = `MM_SELFMENTION${index}`;\n\n        tokens.set(alias, {\n            value: `<span class='mention--highlight'>${mention}</span>`,\n            originalText: mention\n        });\n\n        return prefix + alias;\n    }\n\n    for (const mention of  []){// UserStore.getCurrentMentionKeys()) {\n        // occasionally we get an empty mention which matches a bunch of empty strings\n        if (!mention) {\n            continue;\n        }\n\n        output = output.replace(new RegExp(`(^|\\\\W)(${escapeRegex(mention)})\\\\b`, 'gi'), replaceCurrentMentionWithToken);\n    }\n\n    return output;\n}\n\nfunction autolinkHashtags(text, tokens) {\n    let output = text;\n\n    var newTokens = new Map();\n    for (const [alias, token] of tokens) {\n        if (token.originalText.lastIndexOf('#', 0) === 0) {\n            const index = tokens.size + newTokens.size;\n            const newAlias = `MM_HASHTAG${index}`;\n\n            newTokens.set(newAlias, {\n                value: `<a class='mention-link' href='#' data-hashtag='${token.originalText}'>${token.originalText}</a>`,\n                originalText: token.originalText\n            });\n\n            output = output.replace(alias, newAlias);\n        }\n    }\n\n    // the new tokens are stashed in a separate map since we can't add objects to a map during iteration\n    for (const newToken of newTokens) {\n        tokens.set(newToken[0], newToken[1]);\n    }\n\n    // look for hashtags in the text\n    function replaceHashtagWithToken(fullMatch, prefix, hashtag) {\n        const index = tokens.size;\n        const alias = `MM_HASHTAG${index}`;\n\n        let value = hashtag;\n\n        if (hashtag.length > Constants.MIN_HASHTAG_LINK_LENGTH) {\n            value = `<a class='mention-link' href='#' data-hashtag='${hashtag}'>${hashtag}</a>`;\n        }\n\n        tokens.set(alias, {\n            value,\n            originalText: hashtag\n        });\n\n        return prefix + alias;\n    }\n\n    return output.replace(/(^|\\W)(#[a-zA-ZäöüÄÖÜß][a-zA-Z0-9äöüÄÖÜß.\\-_]*)\\b/g, replaceHashtagWithToken);\n}\n\nconst puncStart = /^[.,()&$!\\[\\]{}':;\\\\]+/;\nconst puncEnd = /[.,()&$#!\\[\\]{}':;\\\\]+$/;\n\nfunction parseSearchTerms(searchTerm) {\n    let terms = [];\n\n    let termString = searchTerm;\n\n    while (termString) {\n        let captured;\n\n        // check for a quoted string\n        captured = (/^\"(.*?)\"/).exec(termString);\n        if (captured) {\n            termString = termString.substring(captured[0].length);\n            terms.push(captured[1]);\n            continue;\n        }\n\n        // check for a search flag (and don't add it to terms)\n        captured = (/^(?:in|from|channel): ?\\S+/).exec(termString);\n        if (captured) {\n            termString = termString.substring(captured[0].length);\n            continue;\n        }\n\n        // capture any plain text up until the next quote or search flag\n        captured = (/^.+?(?=\\bin|\\bfrom|\\bchannel|\"|$)/).exec(termString);\n        if (captured) {\n            termString = termString.substring(captured[0].length);\n\n            // break the text up into words based on how the server splits them in SqlPostStore.SearchPosts and then discard empty terms\n            terms.push(...captured[0].split(/[ <>+\\-\\(\\)\\~\\@]/).filter((term) => !!term));\n            continue;\n        }\n\n        // we should never reach this point since at least one of the regexes should match something in the remaining text\n        throw new Error('Infinite loop in search term parsing: ' + termString);\n    }\n\n    // remove punctuation from each term\n    terms = terms.map((term) => term.replace(puncStart, '').replace(puncEnd, ''));\n\n    return terms;\n}\n\nfunction convertSearchTermToRegex(term) {\n    let pattern;\n    if (term.endsWith('*')) {\n        pattern = '\\\\b' + escapeRegex(term.substring(0, term.length - 1));\n    } else {\n        pattern = '\\\\b' + escapeRegex(term) + '\\\\b';\n    }\n\n    return new RegExp(pattern, 'gi');\n}\n\nfunction highlightSearchTerm(text, tokens, searchTerm) {\n    const terms = parseSearchTerms(searchTerm);\n\n    if (terms.length === 0) {\n        return text;\n    }\n\n    let output = text;\n\n    function replaceSearchTermWithToken(word) {\n        const index = tokens.size;\n        const alias = `MM_SEARCHTERM${index}`;\n\n        tokens.set(alias, {\n            value: `<span class='search-highlight'>${word}</span>`,\n            originalText: word\n        });\n\n        return alias;\n    }\n\n    for (const term of terms) {\n        // highlight existing tokens matching search terms\n        var newTokens = new Map();\n        for (const [alias, token] of tokens) {\n            if (token.originalText === term.replace(/\\*$/, '')) {\n                const index = tokens.size + newTokens.size;\n                const newAlias = `MM_SEARCHTERM${index}`;\n\n                newTokens.set(newAlias, {\n                    value: `<span class='search-highlight'>${alias}</span>`,\n                    originalText: token.originalText\n                });\n\n                output = output.replace(alias, newAlias);\n            }\n        }\n\n        // the new tokens are stashed in a separate map since we can't add objects to a map during iteration\n        for (const newToken of newTokens) {\n            tokens.set(newToken[0], newToken[1]);\n        }\n\n        output = output.replace(convertSearchTermToRegex(term), replaceSearchTermWithToken);\n    }\n\n    return output;\n}\n\nfunction replaceTokens(text, tokens) {\n    let output = text;\n\n    // iterate backwards through the map so that we do replacement in the opposite order that we added tokens\n    const aliases = [...tokens.keys()];\n    for (let i = aliases.length - 1; i >= 0; i--) {\n        const alias = aliases[i];\n        const token = tokens.get(alias);\n        output = output.replace(alias, token.value);\n    }\n\n    return output;\n}\n\nfunction replaceNewlines(text) {\n    return text.replace(/\\n/g, ' ');\n}\n\n// A click handler that can be used with the results of TextFormatting.formatText to add default functionality\n// to clicked hashtags and @mentions.\nexport function handleClick(e) {\n    const mentionAttribute = e.target.getAttributeNode('data-mention');\n    const hashtagAttribute = e.target.getAttributeNode('data-hashtag');\n\n    if (mentionAttribute) {\n        Utils.searchForTerm(mentionAttribute.value);\n    } else if (hashtagAttribute) {\n        Utils.searchForTerm(hashtagAttribute.value);\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./web/static/js/app/utils/text_formatting.jsx\n **/"],"sourceRoot":""}